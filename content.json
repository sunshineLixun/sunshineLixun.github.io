{"meta":{"title":"Hello Li","subtitle":"lx的个人博客","description":"做一个有文艺气息的程序猿","author":"Hello Li","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2016-09-21T13:36:36.000Z","updated":"2016-09-21T13:44:43.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2016-09-21T13:46:11.000Z","updated":"2016-09-21T13:46:43.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-09-21T13:47:57.000Z","updated":"2018-05-02T08:10:03.778Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"技术栈 移动端: Objective-C + Swift + React-Native 前端: React + Redux + react-router + Dva.js + Vue 联系方式 QQ: 1261142605 邮箱: 1261142605@qq.com Github: @Hello Li"}],"posts":[{"title":"算法小集(持续更新)","slug":"算法小集-持续更新","date":"2018-03-20T02:24:13.000Z","updated":"2018-05-10T03:31:45.142Z","comments":true,"path":"2018/03/20/算法小集-持续更新/","link":"","permalink":"http://yoursite.com/2018/03/20/算法小集-持续更新/","excerpt":"","text":"排序桶排序OC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647NSArray *bucketSort(NSArray *list)&#123; NSMutableArray *a = @[].mutableCopy; NSMutableArray *c = [NSMutableArray array]; //初始化数组a中所有元素都为0 for (NSInteger i = 0; i &lt;= 10; i++) &#123; a[i] = @0; &#125; //遍历b中所有元素 当出现数组a中出现b中元素 数组a的这个元素就+1 for (NSNumber *num in list) &#123; NSInteger index = [num integerValue]; //index = 5,2,3,1,8 if (a[index]) &#123; a[index] = @([a[index] integerValue] + 1); &#125; else &#123; a[index] = @0; &#125; &#125; //遍历数组a //从大到小// for (NSInteger i = 10; i &lt; a.count; i --) &#123;// //找到数组a中被增加的元素// if ([a[i] integerValue] &gt; 0) &#123;// [c addObject:@(i)];// &#125;// &#125; //从小到大 for (NSInteger i = 0; i &lt;= 10; i++) &#123; if ([a[i] integerValue] &gt; 0) &#123; [c addObject:@(i)]; &#125; &#125; if (c.count &gt; 0) &#123; return c; &#125; else &#123; return nil; &#125;&#125; JS 12345678910111213141516171819202122232425function bucketSort(list) &#123; if (!Array.isArray(list)) return; let arrayA = [] let arrayC = [] for (let index = 0; index &lt; 10; index++) &#123; arrayA[index] = 0 &#125; list.forEach(element =&gt; &#123; if (element == undefined || element == null) return if (arrayA[element] != undefined || arrayA[element] != null) &#123; arrayA[element] += 1 &#125; else &#123; arrayA[element] = 0 &#125; &#125;) return arrayA.map((item, index) =&gt; &#123; if (item &gt; 0) return index &#125;) &#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041NSArray *quicksort(NSMutableArray *array, NSInteger left, NSInteger right)&#123; if (left &gt; right) &#123; return nil; &#125; //temp 基准数 NSInteger temp = [array[left] integerValue]; NSInteger t = 0; while (left != right) &#123; //从右向左找 while ([array[right] integerValue] &gt; temp &amp;&amp; left &lt; right) &#123; right --; &#125; //从左向右找 while ([array[left] integerValue] &lt; temp &amp;&amp; left &lt; right) &#123; left ++; &#125; //未相遇 if (left &lt; right) &#123; //交换位置 t = [array[left] integerValue]; array[left] = array[right]; array[right] = @(t); &#125; &#125; //left == right 确定基准数位置 array[left] = @(temp); //递归 //处理基准数左边数据 quicksort(array, left, left - 1); //处理基准数右边数据 quicksort(array, left + 1, right); return array;&#125; 冒泡排序OC 12345678910111213NSArray *bubblesort(NSMutableArray *list)&#123; NSNumber *t; for (NSInteger i = 0; i &lt; list.count - 1; i++) &#123; //n个数排序,只用进行n-1趟 for (NSInteger j = 0; j &lt; list.count - 1; j++) &#123; //从第1位开始比较直到最后一位尚未归为的数 因为只进行n-1趟排序,所以最后一位则是n-1。 if (list[j] &gt; list[j + 1]) &#123; t = list[j]; list[j] = list[j+ 1]; list[j + 1] = t; &#125; &#125; &#125; return list;&#125; JS 123456789101112131415function bubbleSort(array) &#123; if (!Array.isArray(array)) return let T = 0; for (let index = 0; index &lt; array.length - 1; index++) &#123; for (let j = 0; j &lt; array.length -1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; T = array[j] array[j] = array[j + 1] array[j + 1] = T &#125; &#125; &#125; return array&#125; 查找二分查找JS 1234567891011121314151617function binary_search(list, item) &#123; let low = 0 let high = list.length - 1 while (low &lt;= high) &#123; const mid = low + high const guess = list[mid] if (guess == item) &#123; return mid &#125; if (guess &gt; item) &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return null&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"AutoLayout - 父视图根据子视图布局自适应大小","slug":"AutoLayout-父视图根据子视图自适应","date":"2017-09-01T07:54:00.000Z","updated":"2018-03-19T09:15:26.758Z","comments":true,"path":"2017/09/01/AutoLayout-父视图根据子视图自适应/","link":"","permalink":"http://yoursite.com/2017/09/01/AutoLayout-父视图根据子视图自适应/","excerpt":"","text":"前言本文记录AutoLayout日常布局UI时的技巧。每当拿到新的界面设计时,比 如这样的: 当某个字段的长度不确定时,(图1中的“作业地址”,图2中”预约地址”和“取消原因”)。Label的行数就要设置为0或者 &gt;=1。总试图的高度就不确定。于是乎就要开始就算containerView的高度了。 1234567891011121314151617- (CGFloat)cellHeight&#123; CGFloat publicHeight = kViewTopPadding + kImageSize().height + kViewTypeMargin + _nameStrSize.height + kViewTypePadding + _nameTextSize.height + kViewTypeMargin / 2 + kCellBottomPadding; switch (_layoutViewType) &#123; case ViewLayoutBreviaryType: return publicHeight; break; case ViewLayoutDetailType: //判断当前model存储的信息是待执行还是已取消状态 if (_orderModel.reserveType == YWBOrderReservationToBeConfirm) &#123; return publicHeight + kViewTypeMargin / 2 + _addressStrSize.height + kViewTypePadding + _addressTextSize.height + kViewTypeMargin + _typeStrSize.height + _typeTextSize.height + kViewTypeMargin + kButtonHeight + kViewBottomPadding + kCellBottomPadding; &#125;else if(_orderModel.reserveType == YWBOrderReservationCancledForSaler || _orderModel.reserveType == YWBOrderReservationCancledForClient)&#123; return publicHeight + kViewTypeMargin / 2 + _addressStrSize.height + kViewTypePadding + _addressTextSize.height + kViewTypeMargin + _cancleStrSize.height + kViewTypePadding + _cancleTextSize.height + kViewBottomPadding + kCellBottomPadding; &#125; break; &#125; return 0.0;&#125; 12345678- (CGFloat)heightWithWidth:(CGFloat)width font:(UIFont *)font&#123; CGRect attrsRect = [self boundingRectWithSize:CGSizeMake(width, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName : font&#125; context:nil]; return attrsRect.size.height;&#125; 如果不细心漏掉某一处高度,查找起来也比较麻烦。每次算高度是我不爱干的一件事情。没有技术含量😂。完全就是细心活。多亏AutoLayout能让我们从这一毫无兴趣的工作中解放出来。 父视图自适应新建Xcode工程。在Main.storyboard的ViewController中随意拖入view控件，颜色暂定为blue。放置3个Label控件。 先不设置blueview的约束。 逐步设置Label的约束。 黑色Label约束如下: 在这里我设置了黑色Label的size。这个并无关系，可设可不设。使用Label的固有大小也行。 黄色Label约束如下: 红色Label约束如下: Label的行数都为0。 重点Label一定要设置距离父视图的间距。这样AutoLayout才能计算出父视图的大小。 最重要的一步看下view的约束将view的固有尺寸设置为placeholder。 我们都知道Label Button ImageView(已经设置image属性)这些控件，在用AutoLayout布局时，只需要设置外边距就行了。AutoLayout会自动适应size大小。这就是固有尺寸。反观View就不行了。假如只设置View的外边距，这时一定会报出约束错误。但是View作为容器。它能根据子控件的大小来自适应。只需要将其固有尺寸(size)都设置为0。 这是对于高度不固定的来讲。如果宽度不固定呢？答案是同样适用，一般来说，view的宽度是固定的。高度不固定。 需要注意的问题如果不设置view的左右边间距或者宽度你就会发现变成了这样:view的左右边距已经被Label撑到屏幕外面了。因为这时view的宽度也是会随着Label变化的。所以说我设置了view的左右边距(或者设置其固定的宽度) 验证接来下就可以设置Label的text属性了。随便输入汉字来验证一下： 可以发现view的高度已经随着Label的变化而变化了。其他的控件以此类推。都是一样的道理。另外纯代码布局也同样适用。 总结view作为容器类其承载其他控件的显示。只要设置了子控件的距离自己的约束。并将自己的固有尺寸设置为placeholder(也就是width和height都为0)。这样AutoLayout就能自动计算出view的大小。 补充怎么样拿到view的大小呢？系统为我们提供了这样的API 1234567891011extension UIView &#123; /* The size fitting most closely to targetSize in which the receiver's subtree can be laid out while optimally satisfying the constraints. If you want the smallest possible size, pass UILayoutFittingCompressedSize; for the largest possible size, pass UILayoutFittingExpandedSize. Also see the comment for UILayoutPriorityFittingSizeLevel. */ @available(iOS 6.0, *) open func systemLayoutSizeFitting(_ targetSize: CGSize) -&gt; CGSize // Equivalent to sending -systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: with UILayoutPriorityFittingSizeLevel for both priorities. @available(iOS 8.0, *) open func systemLayoutSizeFitting(_ targetSize: CGSize, withHorizontalFittingPriority horizontalFittingPriority: UILayoutPriority, verticalFittingPriority: UILayoutPriority) -&gt; CGSize&#125; 在viewDidLayoutSubviews或者layoutSubviews中通过调用上面API就能够获得通过AutoLayout计算过后view的大小。","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"React Native 自定义组件","slug":"React-Native-自定义组件","date":"2017-07-10T08:02:49.000Z","updated":"2018-03-02T06:31:56.250Z","comments":true,"path":"2017/07/10/React-Native-自定义组件/","link":"","permalink":"http://yoursite.com/2017/07/10/React-Native-自定义组件/","excerpt":"","text":"方法一：自定义组件(Button)代码： 12345678910111213export default class Button extends Component&#123; render()&#123; //解构 const &#123;title,onClick&#125; = this.props; return( &lt;TouchableOpacity style=&#123;styles.touchStyle&#125; onPress=&#123;onClick&#125; &gt; &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;;&#125; export default关键字：导出自定义组件,可以被别的js文件所引用。如果没有关键字,就只能在本js文件使用该类。例如在Login.js文件中可以用 1import Button from &apos;./Button&apos; 导入Button组件 12//解构const &#123;title,onClick&#125; = this.props; 解构从父组件的传过来的props, 子组件拿到父组件设置的属性值,显示传递的值或者处理传递过来的方法。 列如上面代码: 12345678///显示Button的title&lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.props.title&#125;&gt;&lt;/Text&gt;///处理TouchableOpacity的点击事件&lt;TouchableOpacity style=&#123;styles.touchStyle&#125; onPress=&#123;onClick&#125;&gt;&lt;/TouchableOpacity&gt; 父组件调用代码: 传递title信息和onClick方法回调 12&lt;Button title=\"登录\" onClick=&#123;() =&gt; alert('点击了登录按钮')&#125;/&gt; 方法二与方法一的区别不大 代码： 1234567891011121314151617181920212223import React, &#123; Component,PropTypes &#125; from 'react';import &#123; Text,TouchableOpacity,StyleSheet &#125; from 'react-native';export default class Button extends Component&#123; static propTypes = &#123; title: PropTypes.string, onPress: PropTypes.func &#125; render()&#123; return( &lt;TouchableOpacity style=&#123;styles.touchStyle&#125; onPress=&#123;()=&gt;&#123; if (this.props.onPress) &#123; this.props.onPress(this) &#125; &#125;&#125; &gt; &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; ) &#125;;&#125; 其中 1234static propTypes = &#123; title: PropTypes.string, onPress: PropTypes.func &#125; 暴露出组件的属性(title)和方法(onPress)。 123456789&lt;TouchableOpacity style=&#123;styles.touchStyle&#125; onPress=&#123;()=&gt;&#123; if (this.props.onPress) &#123; this.props.onPress(this) &#125; &#125;&#125; &gt; &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; 处理TouchableOpacity的点击事件,设置回调函数 显示Button的title 组件调用： 12&lt;Button title=&quot;登录&quot; onPress=&#123;() =&gt; alert(&apos;点击了登录按钮&apos;)&#125;/&gt; Demo","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"记一次React Native的StackNavigator使用小结","slug":"记一次React-Native-StackNavigator使用小结","date":"2017-07-06T08:10:49.000Z","updated":"2018-03-02T06:36:32.918Z","comments":true,"path":"2017/07/06/记一次React-Native-StackNavigator使用小结/","link":"","permalink":"http://yoursite.com/2017/07/06/记一次React-Native-StackNavigator使用小结/","excerpt":"","text":"初始化1234export default ( routeConfigMap: NavigationRouteConfigMap, stackConfig: StackNavigatorConfig = &#123;&#125;) 在StackNavigator的初始化中需要传入两个参数：routeConfigMap 表示路由配置参数, stackConfig表示配置StackNavigatorConfig一些样式或者属性。 123456789101112const MainSrceenStackNavigator = StackNavigator( &#123; MainScreenNavigator: &#123;screen: MainScreenNavigator&#125;, DiscoverDetail: &#123;screen: DiscoverDetail&#125;, SettingDetail: &#123;screen: SettingDetail&#125; &#125;, &#123; initialRouteName: 'MainScreenNavigator', mode:'card', headerMode:'screen', &#125;); 上述代码块配置了3个不同路由的界面，initialRouteName设置根导航控制器界面,默认第一个为根路由。mode表示界面的跳转方式:push或者模态弹出。headerMode表示界面在做跳转时的区域。有三种方式:float,screen,none。float表示不包括导航条在内;screen表示整个屏幕(包括导航条);none表示导航条的隐藏。还有很多属性可选配置。用到可在官网查询React Navigation 。 🌰在我的界面配置导航条样式 123456789101112131415161718static navigationOptions = (&#123;navigation&#125;)=&gt;(&#123; // tabBarLabel: '我的', title: '我', headerStyle:&#123; backgroundColor: 'black' &#125;, headerTitleStyle:&#123; color: 'white' &#125;, tabBarIcon:(&#123;tintColor,focused&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require('./source/我的@2x.png')&#125; selectedImage=&#123;require('./source/我的-选中@2x.png')&#125; /&gt; ), &#125;); 然后再显示出ListView(三个分区的ListView) 123456789constructor(props) &#123; super(props); var ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2,sectionHeaderHasChanged:(s1,s2)=&gt;s1 !== s2&#125;); this.state = &#123; dataSource: ds.cloneWithRowsAndSections([['钱包'],['收藏','相册','卡包','表情'],['设置']]), &#125;; &#125; 1234567891011render()&#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._renderRow.bind(this)&#125; renderSeparator=&#123;this._renderSeparator&#125;&gt; &lt;/ListView&gt; &lt;/View&gt; ) &#125; 分割线 1234567_renderSeparator(sectionID, rowID, adjacentRowHighlighted) &#123; if(sectionID == 1)&#123; return ( &lt;View style=&#123;styles.separatorStyle&#125;&gt;&lt;/View&gt; ) &#125; &#125; ListView每个分区每一行的数据 123456789101112131415161718192021222324252627282930313233343536_renderRow(rowData, sectionID, rowID, highlightRow)&#123; if (sectionID == 0) &#123; return( &lt;TouchableOpacity onPress=&#123;() =&gt;&#123; highlightRow(sectionID,rowID), this.props.navigation.navigate('SettingDetail',&#123;'name': rowData&#125;) &#125;&#125;&gt; &lt;View style=&#123;styles.section_0_style&#125;&gt; &lt;Text style=&#123;&#123;fontSize:15&#125;&#125;&gt;&#123;rowData&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;else if(sectionID == 1)&#123; return( &lt;TouchableOpacity onPress=&#123;() =&gt;&#123; highlightRow(sectionID,rowID), this.props.navigation.navigate('SettingDetail',&#123;'name': rowData&#125;) &#125;&#125;&gt; &lt;View style=&#123;styles.viewStyle&#125;&gt; &lt;Text style=&#123;&#123;fontSize:15&#125;&#125;&gt;&#123;rowData&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;else&#123; return( &lt;TouchableOpacity onPress=&#123;() =&gt;&#123; highlightRow(sectionID,rowID), this.props.navigation.navigate('SettingDetail',&#123;'name': rowData&#125;) &#125;&#125;&gt; &lt;View style=&#123;styles.section_0_style&#125;&gt; &lt;Text style=&#123;&#123;fontSize:15&#125;&#125;&gt;&#123;rowData&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125; &#125; this.props.navigation.navigate(&#39;SettingDetail&#39;,{&#39;name&#39;: rowData}) navigation可用属性来获取。 该函数传递参数{rowData}即ListView每行数据到SettingDetail界面。 再SettingDetail界面中可用下面方法 1234static navigationOptions = (&#123;navigation&#125;) =&gt; (&#123; title:`$&#123;navigation.state.params.name&#125;`, headerBackTitle: '返回', &#125;) 来获取传递过来的参数显示到导航条的title。","categories":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"iOS界面优化系列之：处理图片缩放问题","slug":"iOS界面优化系列之：处理图片缩放问题","date":"2017-02-13T06:56:05.000Z","updated":"2018-03-02T06:40:05.173Z","comments":true,"path":"2017/02/13/iOS界面优化系列之：处理图片缩放问题/","link":"","permalink":"http://yoursite.com/2017/02/13/iOS界面优化系列之：处理图片缩放问题/","excerpt":"","text":"在众多阅读类的APP中，比如: 这类比较稍微简单的界面中充斥着大量的的图片，多则6张,少则3-4张。再者像微博这类重型社交的APP，有的cell都已经有9张图片。图片的优化程度对整个界面的流畅度来说都是重中之重。（另外一个也很重要的地方就是文本的异步渲染），后几个系列也会说到。 像这种异步加载图片的开源库有很多：SD_WebImageView YYWebImage Kingfisher PINRemoteImage …开发者如果只是简单的调用一下 sd_setImageWithURL: 图片能够很好的显示出来。假如从网络加载的图片与自己设置的UIImageView的尺寸不一致,就会导致这种结果。 如果是真机调试 打开Instruments中Core Animation在右侧栏中打开如果是模拟器，打开Debug -&gt;Color Misaligned Images 这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。**黄色、紫色越多，性能越差。 解决办法：1.与后台协商，让后台返回的图片尺寸与客户端UIImageView尺寸一致;2.自己处理。 下面介绍下如何自己处理 12345678910111213141516extension UIImage &#123; func resizeImage(_ image: UIImage, targetSize: CGSize) -&gt; UIImage? &#123; let newRect = CGRect(x: 0, y: 0, width: targetSize.width, height: targetSize.height).integral UIGraphicsBeginImageContextWithOptions(targetSize, false, 0) if let context = UIGraphicsGetCurrentContext() &#123; context.interpolationQuality = .high let flipVertical = CGAffineTransform(a: 1, b: 0, c: 0, d: -1, tx: 0, ty: targetSize.height) context.concatenate(flipVertical) context.draw(self.cgImage!, in: newRect) let newImage = UIImage(cgImage: context.makeImage()!) UIGraphicsEndImageContext() return newImage &#125; return nil &#125;&#125; 很简单就是网络下载下来的图片按照自己设置的UIImageView的尺寸来重新draw一个。 1234567func setImage&lt;T: UIImageView&gt;(_ imageView: T, URLString: String, targetSize: CGSize)&#123; imageView.pin_setImage(from: URL.init(string: URLString), completion: &#123;(PINRemoteImageManagerResult) in if let image = PINRemoteImageManagerResult.image&#123; imageView.image = image.resizeImage(image, targetSize: targetSize) &#125; &#125;) &#125; 重新给UIImageView设置image属性 重新打开Color Misaligned Images功能来检测一下 嗯！ 不错哦，之前的黄色没有了。 本以为就达到了的要求。 但是用Instruments中Time Profiler来检测下处理该函数所需要的时间 用Core Animation来测下FPS 虽然已经很流畅了（注：文本用到了异步绘制）, 基本在54左右， 但是距离满帧59 - 60还差那么一丢丢。 再来观察给UIImage扩展的这个方法 发现它是在主线程中执行，当快速滑动表格时，会有大量的图片在主线程中重新绘制。这个是造成缺失那几帧的主要原因。 解决办法：那就在子线程总去draw, 在主线程中去显示 1234567891011121314151617181920212223extension UIImageView &#123; func drawImage(_ image: UIImage, targetSize: CGSize) &#123; DispatchQueue.global().async &#123; let newRect = CGRect(x: 0, y: 0, width: targetSize.width, height: targetSize.height).integral UIGraphicsBeginImageContextWithOptions(targetSize, false, 0) if let context = UIGraphicsGetCurrentContext() &#123; context.interpolationQuality = .high let flipVertical = CGAffineTransform(a: 1, b: 0, c: 0, d: -1, tx: 0, ty: targetSize.height) context.concatenate(flipVertical) context.saveGState() context.draw(image.cgImage!, in: newRect) context.restoreGState() let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() DispatchQueue.main.async &#123; if let newImage = newImage&#123; self.layer.contents = newImage.cgImage &#125; &#125; &#125; &#125; &#125;&#125; Objective-C 123456789101112131415161718192021-(void)drawImage:(UIImage *)image targetSize:(CGSize )size&#123; dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^&#123; CGRect newRect = CGRectMake(0, 0, size.width, size.height); CGRectIntegral(newRect); UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationHigh); CGAffineTransform transform = CGAffineTransformMake(1, 0, 0, -1, 0, size.height); CGContextConcatCTM(context, transform); CGContextSaveGState(context); CGContextDrawImage(context, newRect, image.CGImage); CGContextRestoreGState(context); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; if (newImage) &#123; self.layer.contents = (id)(newImage.CGImage); &#125; &#125;); &#125;);&#125; 该方法也很简单,在子线程中去重新draw一个UIImage,在主线程中去显示。 调用： 12345678func setImage&lt;T: UIImageView&gt;(_ imageView: T, URLString: String, targetSize: CGSize)&#123; imageView.pin_setImage(from: URL.init(string: URLString), completion: &#123;(PINRemoteImageManagerResult) in if let image = PINRemoteImageManagerResult.image&#123; imageView.drawImage(image, targetSize: targetSize)// imageView.image = image.resizeImage(image, targetSize: targetSize) &#125; &#125;) &#125; 重新测下帧数以及Time Profile 当快速滑动的时候基本上能够达到慢帧的状态 所用的时间也是非常少的。在16ms以内。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"dispatch_semaphore_t 信号量","slug":"dispatch-semaphore-t-信号量","date":"2016-12-08T08:20:14.000Z","updated":"2018-03-16T10:10:04.152Z","comments":true,"path":"2016/12/08/dispatch-semaphore-t-信号量/","link":"","permalink":"http://yoursite.com/2016/12/08/dispatch-semaphore-t-信号量/","excerpt":"","text":"dispatch_semaphore_createdispatch_semaphore_create(long value) 传入的是一个数字,该数字必须大于等于0。列如传入10，表示创建一个信号总量为10信号量（就好比一共有10个停车位）。假如传入0 The starting value for the semaphore. Passing a value less than zero will cause NULL to be returned. 则返回为NULL dispatch_semaphore_wait该函数会使传入的信号量减1,当信号量有 &gt;= 1时,就会继续往下执行。如果没有,该线程就会一直处于等待状态，可阻塞当前线程。该函数需要传入另一个参数 #define DISPATCH_TIME_NOW 表示从现在开始 #define DISPATCH_TIME_FOREVER 表示永不超时 dispatch_semaphore_single该函数会使传入的信号量加1,与dispatch_ semaphore _ wait成对出现。 拿YYKit源码来举例：在#import “UIButton+YYWebImage.m”中 1234567891011121314151617181920212223242526272829303132- (instancetype)init &#123; self = [super init]; //声明一个信号总量为1信号量 _lock = dispatch_semaphore_create(1); _dic = [NSMutableDictionary new]; return self;&#125;- (_YYWebImageSetter *)setterForState:(NSNumber *)state &#123;//是当前线程处于阻塞状态,直到有 &gt;= 1 信号量才会继续执行下面的取值操作 dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); //如果不加入线程锁，就很有可能发生多个线程同时访问_dic字典,造成资源竞争。 _YYWebImageSetter *setter = _dic[state]; //使该信号量加1。保持信号量的平衡，如果没有保持信号量的平衡,可能会出现莫名的bug,甚至crash。 dispatch_semaphore_signal(_lock); return setter;&#125;- (_YYWebImageSetter *)lazySetterForState:(NSNumber *)state &#123; //同理 dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); _YYWebImageSetter *setter = _dic[state]; if (!setter) &#123; setter = [_YYWebImageSetter new]; _dic[state] = setter; &#125; dispatch_semaphore_signal(_lock); return setter;&#125; 在读取_YYWebImageSetter该函数中使用dispatch_semaphore_wait和dispatch_semaphore_signal使当前函数为线程安全。实际上信号量就是锁，它与 @synchronized 函数看起来很像。所起到的作用就是至始至终只会有一个线程去访问该函数。 在 这边文章中很形象的比喻了信号量 123456789101112131415关于信号量，一般可以用停车来比喻。 停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。 信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal 就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value））， 调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个； 当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主 没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这， 所以就一直等下去。 举个🌰 NSMutableArray不是线程安全的,我们可以稍作修饰,线程安全的去更新数组 1234567891011121314NSMutableArray *array = [NSMutableArray array]; dispatch_semaphore_t semphore = dispatch_semaphore_create(1); dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.lx.gcddemo\",DISPATCH_QUEUE_CONCURRENT); dispatch_apply(100, concurrentQueue, ^(size_t i) &#123; dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER); /* @synchronized (array) &#123; [array addObject:[NSNumber numberWithUnsignedInteger:i]]; &#125; */ [array addObject:[NSNumber numberWithUnsignedInteger:i]]; dispatch_semaphore_signal(semphore); &#125;); NSLog(@\"%@\",array);","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"cocoapods 更新到最新版本(1.1.0)","slug":"cocoapods升级1.1.0","date":"2016-10-14T12:45:52.000Z","updated":"2016-10-14T13:00:19.000Z","comments":true,"path":"2016/10/14/cocoapods升级1.1.0/","link":"","permalink":"http://yoursite.com/2016/10/14/cocoapods升级1.1.0/","excerpt":"","text":"在Apple 发布swift3.0之后 一大部分著名的第三方开源库,比如Alamofire,snapKit 之后都陆续更新到swift3.0。当我们用cocoapods管理它们或者使用它们的时候都会看到这样一句话: 1CocoaPods 1.1.0+ is required to build Alamofire 4.0.0+. 1CocoaPods 1.1.0+ is required to build SnapKit 3.0.0+. 需要将cocoapods更新到1.1.0版本以上 1gem install cocoapods --pre //升级到最新版本 但是会遇到权限问题 1ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/pod 需要这么一句话 1sudo gem install cocoapods --pre -n /usr/local/bin cocoa pods 在10.11以上的系统中Apple已经启用无根的安装 stack overflow这么解释: 1This is happening because Apple has enabled rootless on the new install 参考链接 查看cocoapods当前版本 1pod --version 11.1.0.beta.2 此时cocoapods版本就会更新到最新版本.","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]},{"title":"iOS开发小技巧(一)","slug":"iOS开发小技巧(一)","date":"2016-10-10T12:44:20.000Z","updated":"2017-08-10T01:52:24.000Z","comments":true,"path":"2016/10/10/iOS开发小技巧(一)/","link":"","permalink":"http://yoursite.com/2016/10/10/iOS开发小技巧(一)/","excerpt":"","text":"改变UIImagePickerController的导航条以及title的颜色12345678910- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent; UINavigationBar *bar = [UINavigationBar appearance]; NSMutableDictionary *titleDictionary = [NSMutableDictionary dictionary]; titleDictionary[NSForegroundColorAttributeName] = [UIColor whiteColor]; [bar setTitleTextAttributes:titleDictionary]; viewController.navigationController.navigationBar.barTintColor = DIF_BASE_COLOR; viewController.navigationController.navigationBar.tintColor = [UIColor whiteColor];&#125; 利用KVC改变TextField的占位符的颜色1[self.nickNameTextField setValue:[UIColor whiteColor] forKeyPath:@\"_placeholderLabel.textColor\"]; TextView的字数限制123456789101112131415161718192021222324252627282930313233343536373839404142#define MaxNumberOfDescriptionChars 150-(void)textViewEditChanged:(NSNotification *)obj&#123; UITextView *textView = (UITextView *)obj.object; NSString *toBeString = textView.text; NSString *lang = [[UITextInputMode currentInputMode] primaryLanguage]; // 键盘输入模式 if ([lang isEqualToString:@\"zh-Hans\"]) &#123; // 简体中文输入，包括简体拼音，健体五笔，简体手写 UITextRange *selectedRange = [textView markedTextRange]; //获取高亮部分 UITextPosition *position = [textView positionFromPosition:selectedRange.start offset:0]; // 没有高亮选择的字，则对已输入的文字进行字数统计和限制 if (!position) &#123; if (toBeString.length &gt; MaxNumberOfDescriptionChars) &#123; textView.text = [toBeString substringToIndex:MaxNumberOfDescriptionChars]; &#125; &#125; // 有高亮选择的字符串，则暂不对文字进行统计和限制 else&#123; &#125; &#125; // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况 else&#123; if (toBeString.length &gt; MaxNumberOfDescriptionChars) &#123; textView.text = [toBeString substringToIndex:MaxNumberOfDescriptionChars]; &#125; &#125;&#125;- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text&#123; NSString *new = [textView.text stringByReplacingCharactersInRange:range withString:text]; self.numLabel.text = [NSString stringWithFormat:@\"%zd字\",(MaxNumberOfDescriptionChars - new.length)]; if(new.length &gt; MaxNumberOfDescriptionChars)&#123; self.numLabel.text = [NSString stringWithFormat:@\"%zd字\",0]; if (![text isEqualToString:@\"\"]) &#123; return NO; &#125; &#125; return YES;&#125; 判断字符串或者集合类型是否为空1234567891011121314+ (BOOL)isEmpty:(id )obj&#123; if ([obj isKindOfClass:[NSString class]]) &#123; if(obj == nil || [obj class] == [NSNull null] || [obj isEqualToString:@\"\"] || [obj isEqualToString:@\"(null)\"] || [obj isEqualToString:@\"NULL\"] || [obj isEqualToString:@\"&lt;null&gt;\"] || [obj isEqualToString:@\"null\"]) &#123; return YES; &#125; return NO; &#125; if (obj == nil || (NSNull *)obj == [NSNull null] || ([obj respondsToSelector:@selector(length)] &amp;&amp; [obj length] == 0) || ([obj respondsToSelector:@selector(count)] &amp;&amp; [obj count] == 0))&#123; return YES; &#125; return NO;&#125; 给UIResponder添加indexPath属性列如在cell中有button imageview 可以利用该属性找到cell中改该视图objective - C12345@interface UIResponder (Externtion)@property (nonatomic, strong) NSIndexPath *indexPath;@end 123456789- (void)setIndexPath:(NSIndexPath *)indexPath&#123; objc_setAssociatedObject(self, @selector(indexPath), indexPath, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSIndexPath *)indexPath&#123; return objc_getAssociatedObject(self, @selector(indexPath));&#125; swift12345678910111213141516171819extension UIResponder&#123; private struct AssociatedKey &#123; static var AssociatedName = \"AssociatedName\" &#125; public var indexPath: NSIndexPath?&#123; get&#123; return objc_getAssociatedObject(self, &amp;AssociatedKey.AssociatedName) as? NSIndexPath &#125; set&#123; if let newValue = newValue &#123; objc_setAssociatedObject(self, &amp;AssociatedKey.AssociatedName, newValue as NSIndexPath , .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125; &#125;&#125; UIRefreshControl123456789let refresh = UIRefreshControl.init() refresh.tintColor = UIColor.red refresh.attributedTitle = NSAttributedString.init(string: \"正在加载\") refresh.addTarget(self, action: #selector(ViewController.refreshTabeleView(sender:)), for: UIControlEvents.valueChanged) tableView.refreshControl = refresh tableView.addSubview(refresh) tableView.reloadData() 将HTML字符串转化为NSAttributedString富文本字符串123456789- (NSAttributedString *)attributedStringWithHTMLString:(NSString *)htmlString&#123; NSDictionary *options = @&#123; NSDocumentTypeDocumentAttribute : NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute :@(NSUTF8StringEncoding) &#125;; NSData *data = [htmlString dataUsingEncoding:NSUTF8StringEncoding]; return [[NSAttributedString alloc] initWithData:data options:options documentAttributes:nil error:nil];&#125; CABasicAnimation（CAKeyframeAnimation）key path 取值keyPath可以使用的key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- define angle2Radian(angle) ((angle)/180.0*M_PI)transform.rotation.x 围绕x轴翻转 参数：角度 angle2Radian(4)transform.rotation.y 围绕y轴翻转 参数：同上transform.rotation.z 围绕z轴翻转 参数：同上transform.rotation 默认围绕z轴transform.scale.x x方向缩放 参数：缩放比例 1.5transform.scale.y y方向缩放 参数：同上transform.scale.z z方向缩放 参数：同上transform.scale 所有方向缩放 参数：同上transform.translation.x x方向移动 参数：x轴上的坐标 100transform.translation.y x方向移动 参数：y轴上的坐标transform.translation.z x方向移动 参数：z轴上的坐标transform.translation 移动 参数：移动到的点 （100，100）opacity 透明度 参数：透明度 0.5backgroundColor 背景颜色 参数：颜色 (id)[[UIColor redColor] CGColor]cornerRadius 圆角 参数：圆角半径 5borderWidth 边框宽度 参数：边框宽度 5bounds 大小 参数：CGRectcontents 内容 参数：CGImagecontentsRect 可视内容 参数：CGRect 值是0～1之间的小数hidden 是否隐藏positionshadowColorshadowOffsetshadowOpacityshadowRadius 隐藏导航条和tabBar的直线123UINavigationBar *bar = [UINavigationBar appearance];bar.shadowImage = [UIImage new];[bar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; 123UITabBar *tabBar = [UITabBar appearance];tabBar.shadowImage = [UIImage new];tabBar.backgroundImage = [UIImage new]; 全屏手势返回123UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self.interactivePopGestureRecognizer.delegate action:@selector(handleNavigationTransition:)];pan.delegate = self;[self.view addGestureRecognizer:pan]; 1234- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123; return self.childViewControllers.count &gt; 1;&#125; UITextView的placeholder123456789101112131415161718192021- (void)textViewDidBeginEditing:(UITextView *)textView &#123; [self resetTextViewPlaceholderWithText:textView];&#125;- (void)textViewDidEndEditing:(UITextView *)textView &#123; [self resetTextViewPlaceholderWithText:textView];&#125;- (void)resetTextViewPlaceholderWithText:(UITextView *)textView&#123; if ([textView.text isEqualToString:@\"要显示的placeholder\"]) &#123; textView.text = @\"\"; textView.textColor = [UIColor blackColor]; return; &#125; if (textView.text.length &lt; 1) &#123; textView.text = @\"要显示的placeholder\"; textView.textColor = [UIColor colorWithRed:0.87 green:0.87 blue:0.87 alpha:1.00]; return; &#125;&#125; 让应用支持摇一摇 开启摇一摇权限 1[UIApplication sharedApplication].applicationSupportsShakeToEdit = YES; 让view/viewcontroller成为第一响应者 1234#pragma mark - UIResponder- (BOOL)canBecomeFirstResponder &#123; return YES;&#125; 实现方发 123456789101112131415161718192021#pragma mark - 摇动/** * 摇动开始 */- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123; if (motion == UIEventSubtypeMotionShake) &#123; // do some thing &#125;&#125;/** * 摇动结束 */- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123;&#125;/** * 摇动取消 */- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123;&#125; HeaderView随tableview一起滑动123456789101112- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView == self.tableView) &#123; CGFloat headerHeight = DIF_SCREEN_HEIGHT / 3; if (scrollView.contentOffset.y &lt;= headerHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) &#123; scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); &#125;else if (scrollView.contentOffset.y &gt;= headerHeight)&#123; scrollView.contentInset = UIEdgeInsetsMake(-headerHeight, 0, 0, 0); &#125; &#125;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"load VS initialize","slug":"load VS initialize","date":"2016-10-09T12:35:30.000Z","updated":"2018-03-19T09:49:55.771Z","comments":true,"path":"2016/10/09/load VS initialize/","link":"","permalink":"http://yoursite.com/2016/10/09/load VS initialize/","excerpt":"","text":"共同点方法只会被调用一次(相对于runtime而言) 区别load方法声明一个SuperClass类继承与NSObject 1234@implementation SuperClass+ (void) load &#123; NSLog(@\"加载load方法\"); &#125; 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"main\"); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 控制台打印输出 load main 得出结论:load方法在程序启动前就会调用。在main函数之前调用。 initialize方法执行以下代码 1234567+ (void) initialize &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;+ (void) load &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125; 控制台打印输出 12SuperClass +[SuperClass initialize]SuperClass +[SuperClass load] 为什么initialize方法会再load方法前调用呢？通过Apple的文档 1The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. 得知: initialize方法在类的第一个方法被调用前调用。即先执行load方法中的[self class] 就会调用initialize方法。 子类会调用父类的initialize1234567891011121314151617181920212223@interface ChildClass : SuperClass@end@implementation SuperClass+ (void) initialize &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;@end@implementation ChildClass+ (void)load&#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__); &#125;@end 还是导入头文件而不去使用它控制台打印输出 123SuperClass +[SuperClass initialize]ChildClass +[ChildClass initialize]ChildClass +[ChildClass load] 类别(Category)中的+(void)load的+(void)initialize1234567891011121314151617181920212223242526272829303132333435363738394041/******* Interface *******/@interface MainClass : NSObject@end/******* Category Implementation *******/@implementation MainClass(Category)+ (void) load &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;+ (void) initialize &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;@end@implementation MainClass(OtherCategory)+ (void) load &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;+ (void) initialize &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;@end/******* Implementation *******/@implementation MainClass+ (void) load &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;+ (void) initialize &#123; NSLog(@\"%@ %s\", [self class], __FUNCTION__);&#125;@end import 之后 MainClass +[MainClass(OtherCategory) initialize]MainClass +[MainClass load]MainClass +[MainClass(Category) load]MainClass +[MainClass(OtherCategory) load] 先执行类自身的实现，再执行类别(Category)中的实现 不需要调用[super load] 和 [super initialize]123456789+ (void)initialize &#123; //do initialization thing [super initialize];&#125;+ (void) load &#123; //do some loading things [super load];&#125; 这样写是多余的 开发过程中需要注意在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用 参考链接:Objective C类方法load和initialize的区别","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"3D - Touch（二）之Peek & Pop","slug":"3D - Touch之Peek & Pop","date":"2016-09-24T02:21:50.000Z","updated":"2017-02-13T07:22:51.000Z","comments":true,"path":"2016/09/24/3D - Touch之Peek & Pop/","link":"","permalink":"http://yoursite.com/2016/09/24/3D - Touch之Peek & Pop/","excerpt":"","text":"前言在介绍了前面的桌面的3D-Touch,这篇文章来介绍应用中使用peek &amp; pop。 比如QQ 微信中消息界面重压cell就会出现peek &amp; pop。接下来实现这一效果。 实现创建视图(sourceView)首先用tableview来做例子。用storyboard创建表,在这里就不赘述了。 1var titleArray = [\"3D-Touch Objective-C\",\"3D-Touch Swift\",\"前言快报:Swift终将超越OC,进而取代OC\",\"Github9月编程语言 JS 跃居第一位\"] 创建一个数组来做tableview的数据源。 实现代理在实现这一效果之前,需要使当前的控制器实现UIViewControllerPreviewingDelegate代理并且要判断当前设备是否支持Peek &amp; pop: 123if traitCollection.forceTouchCapability == .available&#123; registerForPreviewing(with: self, sourceView: tableView) &#125; 代理中有两个方法: 1public func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? 第一个参数可以获取到要显示的是哪个目标view（sourceView）以及手势,其中有个属性（sourceRect）还可以控制那块区域展示出peek的效果 第二个参数location 顾名思义就是要控制能产生重压的区域。(与第一个参数的sourceRect不同,sourceRect只是哪片区域要展示peek效果,就是在屏幕中视图凸起的那一部分。如果不设置默认就是整个sourceView,而这个参数则是控制哪些区域能使用peek效果)。注意 “能” 和 “要”。这个方法返回的是要显示的那个控制器,就是pop预览的那个控制器。 1public func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) 这个方法就是用来做跳转的。 开始实现代理方法我们需要新建一个控制器来做pop效果,返回出这个控制器。 12345678910func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123; guard let indexPath = tableView.indexPathForRow(at:location) , let cell = tableView.cellForRow(at: indexPath) else &#123; return nil &#125; let detailVC = UIStoryboard.init(name: \"Main\", bundle: nil).instantiateViewController(withIdentifier: \"detail\") as! DetailViewController previewingContext.sourceRect = cell.frame detailVC.text = (cell.textLabel?.text)! return detailVC &#125; 1234 func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) &#123;// self.show(viewControllerToCommit, sender: self) self.navigationController?.pushViewController(viewControllerToCommit, animated: true) &#125; show 和 push都能展示出相同的效果 在显示的控制器中设置代码在detailviewcontroller中需要返回出pop向上拉的选项。（也可以不实现）另外要为了要展示出数据,我在该视图控制器中添加了一个textview来展示数据。 123self.title = \"详情\"self.automaticallyAdjustsScrollViewInsets = falseself.textView.text = text 123456789101112131415161718192021override var previewActionItems: [UIPreviewActionItem]&#123; let action1 = UIPreviewAction.init(title: \"喜欢\", style: .default) &#123; (UIPreviewAction, UIViewController) in &#125; let action2 = UIPreviewAction.init(title: \"收藏\", style: .default) &#123; (UIPreviewAction, UIViewController) in &#125; let cancle = UIPreviewAction.init(title: \"取消\", style: .default) &#123; (UIPreviewAction, UIViewController) in &#125; let delete = UIPreviewAction.init(title: \"删除\", style: .destructive) &#123; (UIPreviewAction, UIViewController) in &#125; let actionGroup = UIPreviewActionGroup.init(title: \"删除\", style: .destructive, actions: [cancle,delete]) return [action1, action2 ,actionGroup] &#125; 返回的数组中存的是UIPreviewAction。这个数组可以是个二维数组,所以可以展示出很多选项。例子中返回的就是一个二维数组。 最后到此整个效果的代码都设置完了。接下来运行程序,看看我们的成果吧:","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"3D - Touch(一) 桌面","slug":"3D-Touch 桌面","date":"2016-09-23T12:07:51.000Z","updated":"2017-09-05T06:46:36.000Z","comments":true,"path":"2016/09/23/3D-Touch 桌面/","link":"","permalink":"http://yoursite.com/2016/09/23/3D-Touch 桌面/","excerpt":"","text":"桌面3D - Touch快捷静态操作（Quick actions）需要在 info.plist中配置 123456789101112131415161718192021222324252627&lt;key&gt;UIApplicationShortcutItems&lt;/key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt; &lt;string&gt;UIApplicationShortcutIconTypeShare&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;弹一弹&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.yuwubao.search&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt; &lt;string&gt;UIApplicationShortcutIconTypeShare&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;摇一摇&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.yuwubao.search&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt; &lt;string&gt;UIApplicationShortcutIconTypeShare&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;扫一扫&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;com.yuwubao.search&lt;/string&gt; &lt;/dict&gt;&lt;/array&gt; 关于几个必须要填写的项： UIApplicationShortcutItemTitle: 表示要显示的标题。展示在你的quick action菜单中的action标题。如果标题一行无法显示并且你没有指定子标题那么它将显示两行。可以使用本地化(localised)。 UIApplicationShortcutItemType: 作为UIApplicationShortcutItem的一部分发送给你的应用。可以依据不同的shortcut类型用于执行你的actions。命名规则为： com.公司名.app名.图标作用名 关于选填的项： UIApplicationShortcutItemIconType: 定义内置图标类型的字符串，可选类型列表可以查询这里 UIApplicationShortcutItemSubtitle: 用户展示你的actions的子标题的字符串。它将显示在你的quick actions标题的下方。可以本地化。 UIApplicationShortcutItemIconFile：一个指定Assets Catalog或者Bundle中的字符串。如果指定了此键，则系统会忽略UIApplicationShortcutItemIconType UIApplicationShortcutItemUserInfo：一个字典，包含你想要解析的其他信息。 第二步在入口类文件（appDelegate）中 12345678910111213func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; //检测版本 if UIDevice.current.systemVersion &gt;= \"9.0\" &#123; let shortcutItem = launchOptions?[UIApplicationLaunchOptionsKey.shortcutItem] as? UIApplicationShortcutItem if let shortcutItem = shortcutItem&#123; self.quickActionWithShortcutItem(shortcutItem: shortcutItem) &#125; &#125; return true &#125; 还要实现另一个方法 12345//MARK: - 3D-Touch func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123; self.quickActionWithShortcutItem(shortcutItem: shortcutItem) completionHandler(true) &#125; 由于代码的冗余 需要定义一个私有的方法 可以根据localizedTitle 或者 type 来区别点击的是哪个。 1234567891011121314private func quickActionWithShortcutItem(shortcutItem: UIApplicationShortcutItem)&#123; let nav = self.window?.rootViewController as? UINavigationController if shortcutItem.localizedTitle == \"弹一弹\"&#123; &#125;else if shortcutItem.localizedTitle == \"摇一摇\"&#123; let detailVC = UIStoryboard.init(name: \"Main\", bundle: nil).instantiateViewController(withIdentifier: \"detail\") as! DetailViewController nav!.pushViewController(detailVC, animated: true) &#125;else&#123; nav!.pushViewController(ThirdViewController(), animated: true) &#125; &#125; 到这里完全设置好了桌面图标的3D - Touch。 由于最近系统升级到了iOS10 桌面icon的3D - Touch 新增了widget。接下来就来时适配iOS10。 Extention(更多信息移步到这里)(喵神博客) Extensions不是独立的应用程序。Extensions必须依赖于一个host app，叫作宿主APP，同时他们的生命周期相互独立，并且可以互相触发事件。一个宿主APP可以包含多个Extensions。本篇文章主要是 Today Extention。创建方法 File-&gt;New-&gt;Target 工程中会多出这些文件 在MainInterface.storyboard中我们可以定制UI。 当我们想纯代码构建UI时,在上图显示的Info.plist中NSExtension需要将NSExtensionMainStoryboard删掉,解除与storyboard的关联 例子中用的storyboard构建UI。 当我们需要与APP通信时。需要用到 URL Shchemes。 首先给label添加手势12widgetLabel.addGestureRecognizer(UITapGestureRecognizer.init(target: self , action: #selector(TodayViewController.widgetLabelAction))) 123@objc private func widgetLabelAction() -&gt; Void &#123; extensionContext?.open(NSURL(string: &quot;simple://finished&quot;) as! URL, completionHandler: nil) &#125; 设置URL Schemes 运行程序 我们也可以在widget中添加自己的APP显示信息了","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Swift基础","slug":"Swift基础","date":"2016-09-20T14:54:59.000Z","updated":"2017-02-13T07:17:40.000Z","comments":true,"path":"2016/09/20/Swift基础/","link":"","permalink":"http://yoursite.com/2016/09/20/Swift基础/","excerpt":"","text":"stride与循环结构区间运算符开区间：[a,b]闭区间：[a,b)举例：1.开区间 123for index in 1..&lt;10&#123; index;&#125; index的值一次为:0~9;可以用此方法遍历数组。比如： 123456var scoreArr = [22,33,44,55,66,77,88,99];var count = scoreArr.count;for index in 0 ..&lt; count&#123; var s = scoreArr[index]; print(s);&#125; 2.闭区间 123for index in 1...10&#123; index;&#125; index的值以此为：0~10 在swift3.0中stride语法已经改为这样:stride(from: , to: , by: )函数和stride(from: , through: , by: )函数stride 方法定义在 Strideable 协议中,swift3.0废弃了传统C的for循环之后，定义的全新方法。stride(from: , to: , by: )相当于开区间；stride(from: , through: , by: )相当于闭区间个人理解：表示从初始数值到目标数值,by:表示跨越的进度（可加可减）。举例： 123for index in stride(from: 10, through: 0, by: -1)&#123; print(index);&#125; 123for index in stride(from: 10, to: 0, by: -1)&#123; print(index);&#125; index的数值:index –10index –9index –8index –7index –6index –5index –4index –3index –2index –1 用stride方法遍历scoreArr数组1234for i in stride(from: 0, to: scoreArr.count, by: 1)&#123; var arr = scoreArr[i]; print(arr);&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"多种方法使tableView的Header下拉放大","slug":"多种方法使tableView的Header下拉放大","date":"2016-09-20T14:15:16.000Z","updated":"2017-02-13T07:15:30.000Z","comments":true,"path":"2016/09/20/多种方法使tableView的Header下拉放大/","link":"","permalink":"http://yoursite.com/2016/09/20/多种方法使tableView的Header下拉放大/","excerpt":"","text":"前言看了峥吖同学的这篇文章【一行代码快速集成tableView头部缩放视图】之后 。想着自己用其他的方法来实现这一效果，于是乎想到 1CGAffineTransformMakeScale 这一方法。 效果图 开始实现在自己写的过程中发现了一些问题, 直接把 1self.tableView.tableHeaderView = self.imageView 之后并不能达到想要的效果。整张图片frame都随着tableview的拖动而改变。并不是像是固定在那里。tableview的顶部会出现大部分空白。然后我仔细看了一遍源码。发现做法是 1[self.tableView insertSubview:imageView atIndex:0]; 接着把一个透明view填充到tableview的header view中。 123UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 200)]; headerView.backgroundColor = [UIColor clearColor]; self.tableView.tableHeaderView = headerView; 找到这一技巧之后。自己写了一个稍微简单的demo。 12345678UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"header\"]];imageView.frame = CGRectMake(0, 0, self.view.frame.size.width, imageViewH);[self.tableView insertSubview:imageView atIndex:0];self.imageView = imageView;UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, imageViewH)];headerView.backgroundColor = [UIColor clearColor];self.tableView.tableHeaderView = headerView; 在 1- (void)scrollViewDidScroll:(UIScrollView *)scrollView 方法中这么写: 123456CGFloat offsetY = scrollView.contentOffset.y; if (offsetY &lt; 0) &#123; self.imageView.frame = CGRectMake(offsetY, offsetY, scrollView.bounds.size.width - offsetY * 2, imageViewH - offsetY); &#125; else &#123; self.imageView.frame = CGRectMake(0, 0, scrollView.bounds.size.width, imageViewH); &#125; 原理一模一样,拿到scrollview的偏移量计算下拉imageview的frame,使其imageview的宽高增大。上拉的时候恢复原来的frame。 另一种方法还是在 1- (void)scrollViewDidScroll:(UIScrollView *)scrollView 方法中拿到scrollview的偏移量计算缩放系数 12345678910111213141516CGFloat offsetY = scrollView.contentOffset.y + scrollView.contentInset.top;CGFloat scale = 1.0;if (offsetY &lt; 0) &#123; //向下拉 scale = MIN(2.5, 1 - offsetY / imageViewH); self.imageView.transform = CGAffineTransformMakeScale(scale, scale); CGRect frame = self.imageView.frame; frame.origin.y = offsetY; self.imageView.frame = frame;&#125;else if(offsetY &gt; 0)&#123; //向上拉 CGRect frame = self.imageView.frame; frame.origin.y = -offsetY/imageViewH; self.imageView.frame = frame;&#125; 再向上拉的过程中要保证imageview不会进行缩放，只是改变下imageview的y轴的值。 最后感谢峥吖同学提供的思路。demo地址:戳我","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}